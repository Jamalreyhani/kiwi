#!/usr/bin/env python
import logging, sys, os, time, glob, re

from pyrocko import wilber, util, model, catalog

from optparse import OptionParser
from tunguska import prepare, sc_edump, configurator

from os.path import join as pjoin
try:
    from subprocess import check_call, CalledProcessError
except:
    from subprocess import call
    # older python versions don't have check_call, emulate it
    class CalledProcessError(Exception):
        pass
            
    def check_call(*args, **kwargs):
        retcode = call(*args, **kwargs)
        if retcode != 0:
            raise CalledProcessError()
    
    
logger = logging.getLogger('autokiwi')

def die(mess):
    messlines = mess.splitlines()
    lead = ''
    for line in messlines:
        logger.critical(lead+line)
        lead = '... '
    
    sys.exit(1)


class GlobalDataRequest(wilber.IrisWilber):
    
    def __init__(self,
            seed_volume_tmpl='events/%(event_name)s/data.seed', 
            vnetcodes=['_GSN-BROADBAND'],
            netcodes=[],
            event_filter_func=None,
            station_filter_func=None,
            before_p=5,
            after_p=5,
            wanted_channels = ['BHZ'],
            **kwargs
            ):

        wilber.IrisWilber.__init__(self, **kwargs)
        self.seed_volume_tmpl = seed_volume_tmpl
        self.vnetcodes = vnetcodes
        self.netcodes = netcodes
        self.event_filter_func = event_filter_func
        self.station_filter_func = station_filter_func
        self.before_p = before_p
        self.after_p = after_p
        self.wanted_channels = wanted_channels

    def station_filter(self, station):
        b = self.station_filter_func is None or self.station_filter_func(station)
        logger.debug('Filter is %s for station %s' % (b, station))
        return b
    
    def event_filter(self, event):
        b = self.event_filter_func is None or self.event_filter_func(event)
        logger.debug('Filter is %s for event %s' % (b, event))
        return b
    
    def event_name(self, event):
        region = '-'.join(event.region.replace('.','').lower().split())
        date_time = time.strftime('%Y-%m-%d_%H-%M-%S', time.gmtime(event.time))
        return '%s_%s' % (region, date_time)

    def pending_events(self, time_range, sorting, force=False):
        events = self.get_events(time_range=time_range)
        events.sort(sorting)
        xevents = []
        for event in events:
            seed_volume = self.seed_volume_tmpl % { 'event_name' : self.event_name(event) }
            if not os.path.exists(seed_volume) or force:
                xevents.append(event)
        
        return xevents
        
    def download_next_event_in_range(self, time_range, sorting, force=False, which=None):
        events = self.get_events(time_range=time_range)
        events.sort(sorting)
        for event in events:
            if which is not None and event.name != which:
                continue
            seed_volume = self.seed_volume_tmpl % { 'event_name' : self.event_name(event) }
            if not os.path.exists(seed_volume) or force:
                util.ensuredirs(seed_volume)
                try:
                    self.get_data(event, outfilename=seed_volume+'.incomplete', vnetcodes=self.vnetcodes, netcodes=self.netcodes,
                                 before=self.before_p, after=self.after_p,
                                 wanted_channels=self.wanted_channels)
                    os.rename(seed_volume+'.incomplete', seed_volume)
                    return self.event_name(event)
                except wilber.WilberNoStations, e:
                    logger.warn("%s (%s)" % (e, self.event_name(event)))
        
        logger.info('Already have all data for given time range and event selection.')
        return None

def event_names_from_pathes(base_config):
    # not nice; reverse lookup event names from pathes
    ev_dirs = glob.glob(base_config.path('event_dir', additional={ 'event_name': '*' }))
    event_names = []
    for ev_dir in ev_dirs:
        if not os.path.isdir(ev_dir): continue
        pat = base_config.path('event_dir') % {'event_name': 'xxxEVENTNAMExxx'}
        pat = re.escape(pat).replace('xxxEVENTNAMExxx', r'([^/]+)')
        m = re.match(pat, ev_dir)
        if m:
            event_names.append(m.group(1))
    return event_names
            
def wilber_pull(config, which='first', force=False, onlylist=False):
    
    r = GlobalDataRequest(
        seed_volume_tmpl    = config.path('seed_volume'),
        event_filter_func   = config.event_filter,
        station_filter_func = config.station_filter,
        vnetcodes           = config.vnetcodes,
        netcodes            = config.netcodes,
        before_p            = config.before_p,
        after_p             = config.after_p,
        username            = config.username,
        email               = config.email,
        wanted_channels     = config.channels)
        
    if config.has('event_sorting'):
        sorting = config.event_sorting
    else:
        # by default get newest event first
        sorting = lambda a,b: cmp(b.time, a.time)
        
    if onlylist:
        return r.pending_events(config.timerange('time_range'), sorting, force=force)
    
    events = []
    while True:
        xwhich = None
        if which != 'all' and which != 'first':
            xwhich = which
        
        ev = r.download_next_event_in_range(
                config.timerange('time_range'), 
                sorting,
                force=force,
                which=xwhich)
                
        if not which == 'all' or ev is None:
            break
        
        seed_volume = config.path('seed_volume') % { 'event_name': ev }
        if os.path.exists(seed_volume):
            events.append(ev)
        
    return events 

def edump_pull(config, which='first', force=False, onlylist=False):
    if config.has('event_sorting'):
        sorting = config.event_sorting
    else:
        # by default get newest event first
        sorting = lambda a,b: cmp(b.time, a.time)
        
    xevents = []
    if config.has('kps_events_file'):
        xevents.extend(model.load_kps_event_list(config.path('kps_events_file')))
        
    if config.has('gfz_events_file'):
        xevents.extend(model.load_gfz_event_list(config.path('gfz_events_file')))
        
    if config.has('use_geofon_catalog') and config.use_geofon_catalog:
        cat = catalog.Geofon()
        tr = config.timerange('time_range')
        xevents.extend(cat.get_events(tr))
    
    xevents.sort(sorting)
    
    events = []
    for event in xevents:
        if  config.has('event_filter') and not config.event_filter(event):
            continue
        edump_data_dir = config.path('edump_data_dir') % { 'event_name': event.name }
        if not force and os.path.exists(edump_data_dir): 
            continue
        events.append(event)
    
    if onlylist:
        return events
        
    if events:
        if which == 'first': 
            events = events[0:1]
        elif which == 'all':
            pass
        else:
            events = [ ev for ev in events if ev.name == which ]
        
        whitelist = lambda tr: True
        if config.has('streams_badness_dir') and config.has('streams_badness_limit'):
            badness_dir = config.path('streams_badness_dir')
            badness_limit = config.streams_badness_limit
            badness = prepare.get_badness(badness_dir, event.time)
            whitelist = lambda tr: tr.nslc_id in badness and badness[tr.nslc_id] <= badness_limit
            
        station_selector = lambda sta: True
        if config.has('station_filter'):
            station_selector = config.station_filter
        
        trace_selector = lambda tr: ( whitelist(tr) and 
                                      tr.channel in config.channels)
       
        dumper = sc_edump.EventDumper( ['edump'] + config.argv, 
            trace_selector = trace_selector,
            station_selector = station_selector,
            time_range = config.time_window,
            event_path = config.path('edump_data_dir'),
            events = events)
            
        dumper()
        ok = []
        for event in events:
            if os.path.exists(edump_data_dir):
                ok.append(event.name)
        return ok
        
    logger.info('Already have all data for given events.')
    return []
    
def run_processing_command(processing_dir, processing_command, event_names):
    for event_name in event_names:
        pdir = processing_dir % { 'event_name': event_name }
        if not os.path.exists(pdir):
            logger.error('Cannot run process on event %s (no processing directory found)' % event_name)
            continue
        oldwd = os.getcwd()
        os.chdir(pdir)
        try:
            check_call(processing_command)
        except CalledProcessError:
            logger.error('Running process on event %s failed.' % event_name)
        os.chdir(oldwd)

def post_event(config, event_names):
    for event_name in event_names:
        source_dir = config.path('source_dir', additional={ 'event_name': event_name }).rstrip('/')
        target_dir = config.path('target_dir', additional={ 'event_name': event_name }).rstrip('/')
        target_host = config.target_host
        trigger_command = [ config.mkpath(xxx, additional={ 'event_name': event_name }) for xxx in  config.trigger_command ]
        
        if os.path.isdir(source_dir):
            target = target_dir
            if target_host:
                target = target_host+':'+target_dir
                
            check_call(['rsync', '-a', source_dir+'/', target ])
            # trigger host to import the new data
            
            check_call(trigger_command)

def load_plugin( plugins_dir, plugin_name):
    if plugins_dir not in sys.path: sys.path[0:0] = [ plugins_dir ]
    plugin_modules = []
    return  __import__(plugin_name)
    
user_home_dir = os.environ['HOME']

usage = '''%prog [options] <command> [args]

%prog [options] pull    [ first | all | eventname ]
%prog [options] prepare ( all | eventnames ... )
%prog [options] process ( all | eventnames ... )
%prog [options] report  ( all | eventnames ... )
%prog [options] post    ( all | eventnames ... )
%prog [options] list
'''

parser = OptionParser(usage=usage)

parser.add_option('--loglevel', 
    action='store', 
    dest='loglevel', 
    type='choice',
    choices=('error', 'warning', 'info', 'debug'), 
    default='warning',
    help='set logger level to "error", "warning", "info", or "debug". '
         'Default is "%default".')

parser.add_option('--config',
    action='store',
    dest='config_filename',
    default='__search_parent_dirs_for_autokiwi.conf__',
    help='set name of config file to use. Default is "%default"')

parser.add_option('--force',
    action='store_true',
    dest='force',
    default=False,
    help='force pulling of events that have already been downloaded')
    
parser.add_option('--pending',
    action='store_true',
    dest='pending',
    default=False,
    help='list events to be pulled')
    
(options, args) = parser.parse_args()

util.setup_logging('autokiwi', options.loglevel)


available_commands = ['pull', 'prepare', 'process', 'report', 'post', 'list']
        
if options.config_filename is '__search_parent_dirs_for_autokiwi.conf__':
    wd = os.getcwd()
    while True:
        fn = pjoin(wd,'autokiwi.conf')
        if os.path.exists(fn):
            config_filename = fn
            break
        nwd, cur = os.path.split(wd)
        if nwd == wd: break
        wd = nwd
else:
    config_filename = options.config_filename


conf = {}
try:
    logger.info('Using config from file %s' % config_filename)
    execfile(config_filename, conf)
except Exception, e:
    die('error in config file: %s' % e)

base_config = conf['base_config']
prepare_config = conf['prepare_config']
kiwi_config = conf.get('kiwi_config', None)
rapid_config = conf.get('rapid_config', None)
wilber_config = conf.get('wilber_config', None)
edump_config = conf.get('edump_config', None)
post_config = conf.get('post_config', None)

try:
    plugins = []
    if base_config.has('plugins_dir'):
        plugins_dir = base_config.path('plugins_dir')
        plugin_names = base_config.plugins
        usage_str = usage
        if plugin_names:
            usage_str += '\nPlugin commands:\n'
        for plugin_name in plugin_names:
            plugin = load_plugin( plugins_dir, plugin_name )
            for command in plugin.__autokiwi_commands__:
                if command in available_commands:
                    die('Command defined more than once: "%s" (in plugin "%s")' % (command, plugin_name))
                available_commands.append(command)
            
            usage_str += plugin.__autokiwi_usage__[command]+'\n'
            plugins.append(plugin)
            
        parser.set_usage(usage_str)

    if len(args) < 1:
        parser.error('required argument is missing')

    commands = args[0].split(',')
    for command in commands:
        if command not in available_commands:
            parser.error('no such command: %s' % command)

    event_names = []
    if 'pull' in commands or ('list' in commands and options.pending):
        pullwhich = 'first'
        if len(args) == 2:
            pullwhich = args[1]
        if len(args) > 2:
            parser.error('too many arguments given for pull')
        
        if wilber_config is None and edump_config is None:
            die('No wilber nor edump configuration found\n(using config from file "%s".)' % (e, config_filename))
            
        if wilber_config:
            event_names = wilber_pull(wilber_config, which=pullwhich, force=options.force, onlylist=options.pending)
            
        elif edump_config:
            event_names = edump_pull(edump_config, which=pullwhich, force=options.force, onlylist=options.pending)
        
        if options.pending:
            for event_name in event_names:
                print event_name
            event_names = []
        else:
            for event_name in event_names:
                print 'downloaded event: %s' % event_name
                
        if not event_names: sys.exit()
    
    if not event_names:
        event_names = args[1:]
    
    if len(event_names) == 1 and event_names[0] == 'all':
        event_names = event_names_from_pathes(base_config)
    
    if not event_names and base_config.has('event_names'):
        event_names = base_config.event_names
            
    for command in commands:
        if command in ('prepare', 'process', 'report', 'post'):
            if not event_names:
                parser.error('What do you want to %s today?' % command)
            
    if 'prepare' in commands:
        prepare.prepare(prepare_config, kiwi_config, rapid_config, event_names)
    
    if 'process' in commands:   
        run_processing_command( kiwi_config.path('main_dir'),
                                    kiwi_config.processing_command,
                                    event_names)
        
    if 'report' in commands:
        run_processing_command( kiwi_config.path('main_dir'),
                                    kiwi_config.report_command,
                                    event_names)
    
    if 'post' in commands:
        if post_config is None:
            die('No post configuration found\n(using config from file "%s".)' % (e, config_filename))
    
        post_event(post_config, event_names)
        
    if 'list' in commands:
        levent_names = event_names_from_pathes(base_config)
        for event_name in levent_names:
            print event_name
    
    for plugin in plugins:
        for command in plugin.__autokiwi_commands__:
            if command in commands:
                plugin.__autokiwi_main__(command, options, conf, event_names)
            
except configurator.ConfigAttributeError, e:
    die('Configuration directive "%s" not found.\n(using config from file "%s".)' % (e, config_filename))
    
    