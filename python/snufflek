#!/usr/bin/env python


import os, sys, signal, logging
import numpy as num
from optparse import OptionParser
from struct import pack

import vtk
from tunguska.QVTKRenderWindowInteractor import QVTKRenderWindowInteractor

import pyrocko.model
import pyrocko.pile
import pyrocko.util
import pyrocko.pile_viewer

from tunguska import glue, source, seismosizer


from PyQt4.QtCore import *
from PyQt4.QtGui import *


def table_to_bin(ifn, ofn):
    """make binary file which vtk can understand from tabular output from seismosizer"""
    
    i = open(ifn)
    o = open(ofn,"w")
    for line in i:
        vals = line.split()
        nvals = len(vals)
        val = vals[-1]
        for ival in range(nvals,4):
            vals.append(val)
            
        data = pack("ffff", *([float(x) for x in vals[:4]]))
        o.write(data)
    
def psm_info_to_vtk(infofilename, outfilenamebase):
    """convert PSM info file to VTK format files"""
    sections = set(["center","outline","rupture","slip","eikonal-grid"])
    i = open(infofilename)
    atsec = ''
    points = []
    for line in i:
        sline = line.strip()
        if sline == '':    # at a section end
            if atsec != '':
                ofn = outfilenamebase+ "-" + atsec +".vtk"
                psm_info_to_vtk_section( atsec, points, ofn )
            atsec = ''
            points = []
            continue
        if sline in sections:
            atsec = sline
            continue
        if atsec != '':
            points.append( sline.split() )
    if atsec != '':
        psm_info_to_vtk_section( atsec, points )
    
    i.close()
    
def psm_info_to_vtk_section(atsec, points, filename ):
    """called by PsmInfoToVtk() for every section <atsec> in the PSM infofile
        with point data in <points>, this then writes a vtk file for this section."""
    npoints = len(points)
    vtk_head = """# vtk DataFile Version 3.1 
generated by minimizer.py
ASCII
DATASET POLYDATA
"""
        
    vtk_head_ugr = """# vtk DataFile Version 3.1 
generated by minimizer.py
ASCII
DATASET UNSTRUCTURED_GRID
"""

    vtk_head_sgr = """# vtk DataFile Version 3.1 
generated by minimizer.py
ASCII
DATASET STRUCTURED_GRID
"""
    
    o = open(filename,"wb")
    
    def vecstr(v):
        return ' '.join([str(e) for e in v])
    
    if atsec == "outline":
        o.write(vtk_head)
        o.write("POINTS %i FLOAT\n" % (npoints*2))
        for p in points:
            o.write(vecstr(p[0:3]) + "\n")
        for p in points:
            o.write(vecstr(p[0:2]) + " 0\n")
        o.write("\nPOLYGONS 2 %i\n" % ((npoints+1)*2))
        o.write(str(npoints)+" ")
        o.write(vecstr(range(0,npoints)) + "\n")
        o.write(str(npoints) + " ")
        o.write(vecstr(range(npoints,npoints*2)) + "\n")
        o.write("\nLINES 2 %i\n" % ((npoints+1)*2))
        o.write(str(npoints)+" ")
        o.write(vecstr(range(0,npoints)) + "\n")
        o.write(str(npoints) + " ")
        o.write(vecstr(range(npoints,npoints*2)) + "\n")

    if atsec == "center":
        o.write(vtk_head)
        o.write("POINTS 2 FLOAT\n")
        o.write(vecstr(points[0][0:2]) + " 0\n" )
        o.write(vecstr(points[0]) + "\n")
        o.write("\nLINES 1 3\n")
        o.write("2 0 1\n")
        
    if atsec == "rupture" or atsec == "slip":
        o.write(vtk_head_ugr)
        o.write("POINTS %i FLOAT\n" % (npoints/2))
        for i in range(0,npoints,2):
            o.write(vecstr(points[i])+"\n")
        o.write("\nPOINT_DATA %i\n" % (npoints/2))
        o.write("VECTORS "+atsec+"vector FLOAT\n")
        for i in xrange(1,npoints,2):
            o.write(vecstr(points[i])+"\n")
            
    if atsec == "eikonal-grid":
        o.write(vtk_head_sgr)
        gridsize = (int(points[0][0]), int(points[0][1]), 1)
        o.write("DIMENSIONS %i %i %i\n" % gridsize)
        o.write("POINTS %i FLOAT\n" % (gridsize[0]*gridsize[1]))
        for i in xrange(1,npoints):
            o.write(vecstr(points[i][0:3])+"\n")
        o.write("\nPOINT_DATA %i\n" % (gridsize[0]*gridsize[1]))
        o.write("SCALARS rupturetime FLOAT 1\n")
        o.write("LOOKUP_TABLE default\n")
        
        itimecol = 3
        if len(points[1]) > 4:
            itimecol = 5
        for i in xrange(1,npoints):
            o.write('%s\n' % points[i][itimecol])
            
    o.close()

class MyValueEdit(QLineEdit):

    def __init__(self, *args):
        apply(QLineEdit.__init__, (self,) + args)
        self.value = 0.
        self.mi = 0.
        self.ma = 1.
        self.connect( self, SIGNAL("editingFinished()"), self.myEditingFinished )
        self.err_palette = QPalette()
        self.err_palette.setColor( QPalette.Base, QColor(255,200,200) )
        self.lock = False
    def setRange( self, mi, ma ):
        self.mi = mi
        self.ma = ma
        
    def setValue( self, value ):
        if not self.lock:
            self.value = value
            self.setPalette( QApplication.palette() )
            self.adjust_text()
        
    def myEditingFinished(self):
        try:
            value = float(str(self.text()).strip())
            if not (self.mi <= value <= self.ma):
                raise Exception("out of range")
            if value != self.value:
                self.value = value
                self.lock = True
                self.emit(SIGNAL("edited(float)"), value )
                self.setPalette( QApplication.palette() )
        except:
            self.setPalette( self.err_palette )
        
        self.lock = False
        
    def adjust_text(self):
        self.setText( ("%8.5g" % self.value).strip() )
        
class ValControl(QFrame):

    def __init__(self, *args):
        apply(QFrame.__init__, (self,) + args)
        self.layout = QHBoxLayout( self )
        #self.layout.setSpacing(5)
        self.lname = QLabel( "name", self )
        self.lname.setFixedWidth(120)
        self.lvalue = MyValueEdit( self )
        self.lvalue.setFixedWidth(100)
        self.slider = QSlider(Qt.Horizontal, self)
        self.slider.setMaximum( 10000 )
        self.slider.setSingleStep( 100 )
        self.slider.setPageStep( 1000 )
        self.slider.setTickPosition( QSlider.NoTicks )
        self.layout.addWidget( self.lname )
        self.layout.addWidget( self.lvalue )
        self.layout.addWidget( self.slider )
        #self.setSizePolicy(QSizePolicy.Expanding,QSizePolicy.Fixed)
        self.connect( self.slider, SIGNAL("valueChanged(int)"),
                      self.slided )
        self.connect( self.lvalue, SIGNAL("edited(float)"),
                      self.edited )
                          
    def setup(self, name, mi, ma, cur, ind):
        self.lname.setText( name )
        self.mi = mi
        self.ma = ma
        self.cur = cur
        self.cursl = float(cur-mi)/(ma-mi) * 10000.
        self.ind = ind
        self.lvalue.setRange( mi, ma )
        self.lvalue.setValue( self.cur )
        self.slider.setValue( self.cursl )
        
    def slided(self,val):
        if self.cursl != val:
            self.cursl = val
            self.cur = self.mi+(self.ma-self.mi)*self.cursl/10000.
            self.lvalue.setValue( self.cur )
            self.emit(SIGNAL("valchange(float,int)"), float(self.cur), int(self.ind) )

    def edited(self,val):
        if self.cur != val:
            self.cur = val
            cursl = (self.cur-self.mi)/(self.ma-self.mi) * 10000.
            if (cursl != self.cursl):
                self.slider.setValue( cursl )
            
            self.emit(SIGNAL("valchange(float,int)"), float(self.cur), int(self.ind) )
        
   
        
def printChildren(obj, indent=""):
    children=obj.children()
    if children==None:
        return
    for child in children:
        print indent, child.name(), child.__class__
        printChildren(child, indent + "  ")
        
class ValControlPan(QScrollArea):
    
    def __init__(self, *args ):
        apply(QScrollArea.__init__, (self,) + args  )
        self.frame = False
   
    def setup(self, names, mins, maxs, curs):
        n = len(names)
        self.setWidgetResizable( True )
        if (self.frame):
            self.frame.hide()
            
        self.frame = QFrame(self)
        self.setWidget( self.frame )
        grid = QGridLayout(self.frame)
        grid.setMargin(5)
        grid.setSpacing(5)
        self.data = curs
        for i in range(n):
            valc = ValControl(self.frame)
            grid.addWidget(valc,i,1)
            
            valc.setup( names[i], mins[i], maxs[i], curs[i], i)
            
            
            self.connect( valc, SIGNAL("valchange(float,int)"), self.valchange )
        self.frame.show()
            
    def valchange(self, value, index):
        self.data[index] = value
        self.emit( SIGNAL("valchange(PyQt_PyObject)"), self.data )

class MyWindow(QMainWindow):

    def __init__(self, clargs, *args):
        apply(QMainWindow.__init__, (self,) + args )
        self.valpan = ValControlPan( self )

        self.setWindowTitle( "Seismosizer" )
        
        self.filemenu = self.menuBar().addMenu( "&File" )
        self.filemenu.addAction( "&Render Sequence", self.rendersequence )
        self.filemenu.addAction( "&Save Image", self.rendertofile )
        self.filemenu.addAction( "&Quit", qApp.quit )
        
        self.sourcemenu = self.menuBar().addMenu( "Source&type" )
        
        if (len(clargs) < 6): 
            sys.exit("usage: snufflek database effective-dt origin-lat origin-lon receiver-lat receiver-lon files ...")
            
        gfdb_path = clargs[0]
        effective_dt, origin_lat, origin_lon, rec_lat, rec_lon = [ float(x) for x in clargs[1:6] ]
        
        event = pyrocko.model.Event(lat=origin_lat, lon=origin_lon, time=0.0)
        station = pyrocko.model.Station('','','', lat=rec_lat, lon=rec_lon, elevation=0.0)
        station.add_channel(glue.kiwi_channels['a'])
        station.add_channel(glue.kiwi_channels['r'])
        station.add_channel(glue.kiwi_channels['u'])
        
        seis = glue.start_seismosizer(gfdb_path, event, stations=[station], effective_dt=effective_dt, local_interpolation='nearest_neighbor')
        self.trace_consumer = None

        self.vis = None
        self.seismosizer = seis
        self.tempfilebase = self.seismosizer.tempdir+'/snuff'
        
        
        defaultsource = "bilateral"
        params = (0.00E+00,  0.00E+00,  0.00E+00,  2.00E+03,  7.00E+13,  0.00E+00,  8.00E+01,  0.00E+00, 0.00E+00,  0.00E+00,  0.00E+00,  0.00E+00,  3.50E+03,  0.10E+00)
        self.setSourceType( defaultsource, params=params)
        
        self.dockwin = QDockWidget('Source Model Parameters')
        self.dockwin.setWidget( self.valpan )
        self.addDockWidget(Qt.RightDockWidgetArea, self.dockwin)
        self.connect( self.valpan, SIGNAL("valchange(PyQt_PyObject)"),
                      self.calculate )
                              
        self.vis = Visualization(self.tempfilebase)

        #visdockwin = QDockWidget('Source Model View')
        #visdockwin.setWidget(self.vis.get_view())
        self.vis.get_view().show()
        #self.addDockWidget(Qt.LeftDockWidgetArea, visdockwin)
                
                
        sourcegroup = QActionGroup( self )
        sourcegroup.setExclusive( True )
                
        for name in source.source_types():
            item = QAction( name, self )
            item.setCheckable( True )
            item.setChecked( name == defaultsource )
            self.sourcemenu.addAction( item )
            sourcegroup.addAction( item )
        self.connect( sourcegroup, SIGNAL("triggered(QAction*)"), self.selectedSourceFromMenu )
        self.sourcegroup = sourcegroup
        
   
    def selectedSourceFromMenu(self, action):
        name = str(action.text())
        self.setSourceType( name )
        
    def setSourceType(self, name, params=None):
        self.sourcetype = name
        self.source = source.Source(self.sourcetype)
        para = source.source_infos_flat(self.sourcetype)
        
        if params != None:
            for iparam in range(min(len(params),len(para['default']))):
                para['default'][iparam] = params[iparam]
                
                #if para['soft_min'][iparam] < para['default'][iparam]:
                #    para['soft_min'][iparam] = para['default'][iparam] *0.001
                
        
        print para['soft_min']
                
        self.valpan.setup( para['name'], para['soft_min'], para['soft_max'], para['default'] )
        self.calculate( para['default'] )
        
    def calculate(self,data):
        self.source.update_from_list(data)
        self.seismosizer.set_source( self.source )
        self.seismosizer.do_output_source_model( self.tempfilebase )
        self.seismosizer.do_output_seismograms( self.tempfilebase, "mseed", "synthetics", "plain")

        for irec, rec in enumerate(self.seismosizer.receivers):
            irec_fortran = irec+1
            for comp in rec.components:
                fn = '%s-%i-%s.%s' % (self.tempfilebase, irec_fortran, comp, 'mseed')
                tr = pyrocko.io.load(fn)[0]
                network = rec.get_network()
                station = rec.get_station()
                
                tr.set_codes(network, station, 'sy', comp)
                if self.trace_consumer:
                    self.trace_consumer.got_trace(tr)
                
        table_to_bin( self.tempfilebase+'-dsm.table', self.tempfilebase+'-dsm.bin' )
        psm_info_to_vtk( self.tempfilebase+'-psm.info', self.tempfilebase+'-psm' )
        
        if self.vis:
            self.vis.modified()

    def set_trace_consumer(self, obj):
        self.trace_consumer = obj

    def rendertofile( self ):
        if self.vis: 
            filename_skeleton = 'picasso-%i.png'
            filename = get_available_filename( filename_skeleton )
            self.vis.rendertofile(filename)
            
    def rendersequence( self ):
        filename = QFileDialog.getOpenFileName( self.win, "Open Source Sequence" )
        if os.path.exists(filename):
            file = open(filename, 'r')
            for line in file:
                toks = line.split()
                sourcetype = toks[0]
                params = [ float(x) for x in toks[1:] ]
                self.win.setSourceType( sourcetype, params )
                self.rendertofile()
            file.close()


def get_available_filename( skeleton ):
    i = 0
    while True:
        filename = skeleton % i
        if not os.path.exists( filename ): return filename
        i += 1
            
            
            
class SurfaceGrid(vtk.vtkUnstructuredGrid):
   
    
    def setup(self, delta=(5000.,5000.), nrange=((-10,11),(-10,11))):
        self.delta = delta
        self.nrange = nrange
        
        points = []
        for ix in xrange(*self.nrange[1]):
            x = self.delta[1]*ix
            vline = vtk.vtkLineSource()
            ymin = self.delta[0]*self.nrange[0][0]
            ymax = self.delta[0]*(self.nrange[0][1]-1)
            points.append( (x,ymin,0) )
            points.append( (x,ymax,0) )
            
        for iy in xrange(*self.nrange[0]):
            y = self.delta[0]*iy
            vline = vtk.vtkLineSource()
            xmin = self.delta[1]*self.nrange[1][0]
            xmax = self.delta[1]*(self.nrange[1][1]-1)
            points.append( (xmin,y,0) )
            points.append( (xmax,y,0) )
        
        vpoints = vtk.vtkPoints()
        vpoints.SetNumberOfPoints(len(points))
        for i, point in enumerate(points):
            vpoints.InsertPoint(i, point)
        
        self.Allocate(len(points)/2, len(points)/2)
        self.SetPoints( vpoints )
        for i in xrange(0,len(points),2):
            iline = i/2
            vline = vtk.vtkLine()
            vline.GetPointIds().SetId(0,i)
            vline.GetPointIds().SetId(1,i+1)
            self.InsertNextCell( vline.GetCellType(), vline.GetPointIds() )
        
        
class Visualization:
    def __init__(self,fnbase):
    
        color_fg = (0.,0.,0.)
        color_bg = (1.,1.,1.)
        color_plane = (0.,1.,.5)
        
        fpreader = vtk.vtkPolyDataReader()
        fpreader.SetFileName( fnbase+"-psm-outline.vtk" )
        self.fpreader = fpreader
        
        fpmapper = vtk.vtkPolyDataMapper()
        fpmapper.SetInput( fpreader.GetOutput() )
        
        fpmapper2 = vtk.vtkPolyDataMapper()
        fpmapper2.SetInput( fpreader.GetOutput() )
        
        fpactor = vtk.vtkActor()
        fpactor.SetMapper( fpmapper );
        fpactor.GetProperty().SetColor(color_plane)
        fpactor.GetProperty().SetDiffuse(0.2 )
        fpactor.GetProperty().SetAmbient(0.2)
        fpactor.GetProperty().SetOpacity(0.3)
        fpactor.GetProperty().EdgeVisibilityOff()
        #fpactor.GetProperty().SetEdgeColor(color_fg)
        #fpactor.GetProperty().SetLineWidth(5)
        
        
        fpactor2 = vtk.vtkActor()
        fpactor2.SetMapper( fpmapper2 );
        fpactor2.GetProperty().SetColor( *color_fg )
        fpactor2.GetProperty().SetRepresentationToWireframe()
        fpactor2.GetProperty().SetLineWidth(1.)
        fpactor2.GetProperty().SetOpacity(0.6)
  
        
        cereader = vtk.vtkPolyDataReader()
        cereader.SetFileName( fnbase+"-psm-center.vtk" )
        self.cereader = cereader
        
        cemapper = vtk.vtkPolyDataMapper()
        cemapper.SetInput( cereader.GetOutput() )
        
        ceactor = vtk.vtkActor()
        ceactor.SetMapper( cemapper );
        ceactor.GetProperty().SetDiffuseColor( *color_fg )
        ceactor.GetProperty().SetRepresentationToWireframe()
        
        
        rupreader = vtk.vtkDataSetReader()
        rupreader.SetFileName( fnbase+"-psm-rupture.vtk" )
        self.rupreader = rupreader
        
        arrow = vtk.vtkArrowSource()
        arrow.SetShaftRadius(0.03)
        arrow.SetTipLength(0.16)
        arrow.SetTipRadius(0.05)
        
        arrows = vtk.vtkGlyph3D()
        arrows.SetInput(rupreader.GetOutput())
        arrows.SetSource(arrow.GetOutput())
        arrows.SetVectorModeToUseVector()
        arrows.SetScaleModeToScaleByVector()
        arrows.OrientOn()
        
        rupmapper = vtk.vtkPolyDataMapper()
        rupmapper.SetInput( arrows.GetOutput() )
        
        rupactor = vtk.vtkActor()
        rupactor.SetMapper( rupmapper );
        rupactor.GetProperty().SetDiffuseColor( *color_fg )
        rupactor.GetProperty().SetOpacity(0.3)

        slreader = vtk.vtkDataSetReader()
        slreader.SetFileName( fnbase+"-psm-slip.vtk" )
        self.slreader = slreader
        
        arrow2 = vtk.vtkArrowSource()
        arrow2.SetShaftRadius(0.09)
        arrow2.SetTipLength(0.48)
        arrow2.SetTipRadius(0.15)
        
        arrows2 = vtk.vtkGlyph3D()
        arrows2.SetInput(slreader.GetOutput())
        arrows2.SetSource(arrow2.GetOutput())
        arrows2.SetVectorModeToUseVector()
        arrows2.SetScaleModeToScaleByVector()
        arrows2.OrientOn()
        
        slmapper = vtk.vtkPolyDataMapper()
        slmapper.SetInput( arrows2.GetOutput() )
        
        slactor = vtk.vtkActor()
        slactor.SetMapper( slmapper );
        slactor.GetProperty().SetDiffuseColor( 1.,1.,0. )
        
        
        reader = vtk.vtkParticleReader()
        reader.SetFileName( fnbase+"-dsm.bin" )
        reader.SetDataByteOrderToLittleEndian()
        self.reader = reader
            
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInput( reader.GetOutput() )
        self.centroids_mapper = mapper

        actor = vtk.vtkActor()
        actor.SetMapper( mapper );
        actor.GetProperty().SetPointSize(5)
        
        
        #plane = vtk.vtkPlaneSource()
        #plane.SetOrigin(0.,0.,0.)
        #plane.SetPoint1(10000.,0.,0.)
        #plane.SetPoint2(0.,10000.,0.)
        #plane.SetCenter(0.,0.,0.)
                
        sgrid = SurfaceGrid()
        sgrid.setup()
        
        sgridMapper = vtk.vtkDataSetMapper()
        sgridMapper.SetInput(sgrid)
        
        sgridActor = vtk.vtkActor()
        sgridActor.SetMapper( sgridMapper )
        sgridActor.GetProperty().SetDiffuseColor( *color_fg )
        sgridActor.GetProperty().SetOpacity( 0.2 )
        
        labels = {}
        for direction in ('North','East','South','West'):
            atext = vtk.vtkVectorText()
            atext.SetText(direction)
            textMapper = vtk.vtkPolyDataMapper()
            textMapper.SetInputConnection(atext.GetOutputPort())
            textActor = vtk.vtkFollower()
            textActor.SetMapper(textMapper)
            center = textActor.GetCenter()
            textActor.SetOrigin( center )

            textActor.SetScale(1000.,1000.,1000.)
            textActor.GetProperty().SetDiffuseColor( *color_fg )
            labels[direction] = textActor
            
        labels['North'].AddPosition( 50000., 0., -1000.)
        labels['South'].AddPosition(-50000., 0., -1000.)
        labels['East'].AddPosition(0.,  50000., -1000.)
        labels['West'].AddPosition(0., -50000., -1000.)
        
        

        #planeMapper = vtk.vtkPolyDataMapper()
        #planeMapper.SetInput(plane.GetOutput())
        #planeActor = vtk.vtkActor()
        #planeActor.SetMapper(planeMapper)
        #planeActor.GetProperty().SetOpacity( 0.2 )
        #planeActor.GetProperty().SetDiffuseColor( *color_fg )
        
        #outlineData = vtk.vtkOutlineFilter()
        #outlineData.SetInput(fpreader.GetOutput())
        #mapOutline = vtk.vtkPolyDataMapper()
        #mapOutline.SetInput(outlineData.GetOutput())
        #outline = vtk.vtkActor()
        #outline.SetMapper(mapOutline)
        #outline.GetProperty().SetColor(1.,1.,1.)
        #outline.GetProperty().SetLineWidth(2.)

        camera = vtk.vtkCamera()
        camera.SetClippingRange(10., 500000.)
        camera.SetFocalPoint(0.,0.,0.)
        camera.SetPosition(-30000.,0.,-30000.)
        camera.SetViewUp(0.,0.,-1.)
       
        egreader = vtk.vtkStructuredGridReader()
        egreader.SetFileName(fnbase+"-psm-eikonal-grid.vtk")
        
        blankgrid = vtk.vtkBlankStructuredGrid()
        blankgrid.SetInput( egreader.GetOutput() )
        blankgrid.SetArrayName("rupturetime")
        blankgrid.SetMinBlankingValue(-2)
        blankgrid.SetMaxBlankingValue(-0.1)

        iso = vtk.vtkContourFilter()
        iso.SetInputConnection(blankgrid.GetOutputPort())
        iso.GenerateValues(201,-50.,50.)
        
        isomapper = vtk.vtkPolyDataMapper()
        isomapper.SetInputConnection(iso.GetOutputPort())
        isomapper.ScalarVisibilityOff()
        
        egplaneActor = vtk.vtkActor()
        egplaneActor.SetMapper(isomapper)
        egplaneActor.GetProperty().SetLineWidth(2.)
        egplaneActor.GetProperty().SetColor(color_fg)
        self.egreader = egreader
        self.isomapper = isomapper

        ren = vtk.vtkRenderer()
        ren.SetBackground(*color_bg)
        ren.SetActiveCamera(camera)

        ren.AddActor(ceactor)
        ren.AddActor(fpactor)
        ren.AddActor(fpactor2)
        ren.AddActor(slactor)
        ren.AddActor(rupactor)
        ren.AddActor(actor)
        ren.AddActor(sgridActor)
        ren.AddActor(egplaneActor)
        for label in labels.values():
            ren.AddActor(label)
            label.SetCamera(ren.GetActiveCamera())

        #ren.AddActor(outline)
        ren.SetViewport(0, 0, 1, 1)

       
        vtkview = QVTKRenderWindowInteractor()
        vtkview.SetInteractorStyle( vtk.vtkInteractorStyleTerrain() )
        renWin = vtkview.GetRenderWindow()
        renWin.LineSmoothingOn()
        renWin.PolygonSmoothingOn()
        renWin.PointSmoothingOn()
        renWin.AddRenderer(ren)
        
        imagefilter = vtk.vtkWindowToImageFilter()
        imagefilter.SetInput( renWin )
        
        imagewriter = vtk.vtkPNGWriter()
        imagewriter.SetInputConnection( imagefilter.GetOutputPort() )
        
        
        self.vtkview = vtkview
        self.renwin = renWin
        self.reader = reader
        self.imagefilter = imagefilter
        self.imagewriter = imagewriter
        
    def get_view(self):
        return self.vtkview
        
    def modified(self):
        self.reader.Modified()
        self.fpreader.Modified()
        self.cereader.Modified()
        self.slreader.Modified()
        self.rupreader.Modified()
        self.egreader.Modified()
        
        rs = [0,0]
        self.egreader.GetOutput().GetScalarRange(rs)
       
        self.isomapper.SetScalarRange(rs)
        
        self.reader.GetOutput().GetScalarRange( rs )
        self.centroids_mapper.SetScalarRange( rs )
        
        self.renwin.Render()

    def rerender(self):
        self.renwin.Render()
    
    def rendertofile(self, filename):
        self.modified()
        self.imagefilter.Modified()
        self.imagewriter.SetFileName(filename)
        self.imagewriter.Write()
  

class MySnuffler(QApplication):
    
    app = None
    
    def __init__(self, *args):
        apply(QApplication.__init__, (self,) + args)
        
        parser = OptionParser()
        parser.add_option('--pattern', dest='pattern')
        parser.add_option('--ntracks', dest='ntracks', default=24)
        parser.add_option('--format', dest='format', default='from_extension', 
                          choices=('mseed', 'sac', 'kan', 'segy', 'from_extension', 'try'))
        parser.add_option('--debug', dest='debug', action='store_true', default=False)

        options, args = parser.parse_args(list(args[0][1:]))
        
        if options.debug:
            pyrocko.util.setup_logging('snuffler', 'debug')
        else:
            pyrocko.util.setup_logging('snuffler', 'warning')
        
        filenames = pyrocko.util.select_files( args[6:], regex=options.pattern )
        cachedirname = '/tmp/snuffle_cache_%s' % os.environ['USER']
        cache = pyrocko.pile.get_cache(cachedirname)
        pile = pyrocko.pile.Pile()
        pile.add_files( sorted(filenames), cache=cache, 
                        filename_attributes=options.pattern,
                        fileformat=options.format )

        self.pile_viewer = pyrocko.pile_viewer.PileViewer(pile, ntracks_shown_max=options.ntracks)
        
        if os.path.isfile('markers'):
            markers = num.sort(num.loadtxt('markers'), axis=0)
            self.pile_overview.set_markers( markers )
        
        self.win = MyWindow(args)
        self.win.set_trace_consumer(self)
        self.win.setWindowTitle( "SnuffleK" )        
        self.win.setCentralWidget( self.pile_viewer )
        self.win.show()

        sb = self.win.statusBar()
        sb.clearMessage()
        sb.showMessage('Welcome to Snuffler! Click and drag to zoom and pan. Doubleclick to pick. Right-click for Menu. <space> to step forward. <b> to step backward. <q> to close.')

        self.connect(self, SIGNAL("lastWindowClosed()"), self.myquit)
        signal.signal(signal.SIGINT, self.myquit)
        
        self.traces = {}
        self.traces_to_files = {}
        
        self.timer = QTimer( self )
        self.timer.setSingleShot( False )
        self.connect( self.timer, SIGNAL("timeout()"), self.periodical ) 
        self.timer.start( 1000 )
        self.goaway = False
        
    
    def myquit(self, *args):
        self.win.seismosizer.close()
        self.quit()

    def periodical(self):
        if self.goaway:
            self.myquit()

    def timetogo(self,*args):
        self.goaway = True

    def setwin( self, win ):
        self.win = win
                                
    def setvis( self, vis ):
        self.vis = vis

    def got_trace(self, tr):
        nslc = tr.nslc_id
        trnew = False
        need_full_update = False
        if nslc in self.traces:
            trbuf = self.traces[nslc]
            trbuf.ydata = tr.ydata
            if tr.tmin > trbuf.tmin or tr.tmax < trbuf.tmax:
                need_full_update = True
            trbuf.tmin = tr.tmin
            trbuf.tmax = tr.tmax
            tr = trbuf            
        else:
            trnew = True
            
        if trnew:
            self.traces[nslc] = tr
            memfile = pyrocko.pile.MemTracesFile(None,[tr])
            p = self.pile_viewer.get_pile()
            p.add_file(memfile)
            self.traces_to_files[tr] = memfile
        
        if need_full_update:
            self.traces_to_files[tr].recursive_full_update()
        else:
            self.traces_to_files[tr].recursive_grow_update([tr])
        
        self.pile_viewer.pile_overview.update()



def main(args):
    
    app = MySnuffler(args)
    app.exec_()
    
    if pyrocko.pile_viewer.Global.sacflag: pyrocko.pile_viewer.sac_exec()
    sys.exit()

if __name__=="__main__":
    main(sys.argv)
